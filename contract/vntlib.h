
// vnt contract standard library
// All methods that the vnt contract can call will be defined in the standard library
// Need to reference the standard library when writing contract code
// The methods in the standard library are implemented in the vnt-wasm virtual machine

//###################################################################

#include <stdbool.h> //Support bool type
#ifndef _DEFINE_VNTLIB_H
#define _DEFINE_VNTLIB_H

#define VNT_WASM_EXPORT __attribute__((visibility("default"))) //Export method
#define MUTABLE VNT_WASM_EXPORT                                //Define methods to export and modify state variable
#define UNMUTABLE \
     VNT_WASM_EXPORT                      //Define the method that needs to be exported, this method can read the state variable but will not modify the state variable
#define EVENT void //Empty macro, keyword used when declaring Event function
#define indexed //Empty macro, when declaring Event function, keywords used when defining parameters that need to be indexed
#define CALL //Empty macro, declare the keywords used when calling functions across contracts
#define KEY volatile //Macro, declare global variables
#define constructor VNT_WASM_EXPORT void //Empty macro, used when declaring constructor
#define _ VNT_WASM_EXPORT void Fallback //Macro, fallback function symbol
#define $_ VNT_WASM_EXPORT void $Fallback //Macro, payable fallback function symbol
#define N(name) (#name) //Macro, which directly converts the input into string form
#define CAT(n) n##n
#define U256(n) ("u2561537182776" #n) //Macro used when declaring uint256 type
#define Address(n) ("address1537182776" n) //Macro used when declaring address type


#define now GetTimestamp() //Get the timestamp of block generation
//#define years(n) (60 * 60 * 24 * 365 * n)UL;
#define years(n) n * 31536000UL
//#define weeks(n) (60 * 60 * 24 * 7 * n)UL;
#define weeks(n) n * 604800UL
//#define days(n) (60 * 60 * 24 * n)UL;
#define days(n) n * 86400UL
//#define hours(n) (60 * 60 * n)UL;
#define hours(n) n * 3600UL
//#define minutes(n) (60 * n)UL;
#define minutes(n) n * 60UL
// seconds is the basic unit
#define seconds(n) n * 1UL

//The following is the definition of the types supported by the contract
typedef unsigned long long uint64;
typedef unsigned long uint32;
typedef long long int64;
typedef long int32;
typedef char *string;
// uint256 is actually a char array
typedef char *uint256;
typedef char *address;

//Type tag used in the second compilation
#define TY_INT32 1
#define TY_INT64 2
#define TY_UINT32 3
#define TY_UINT64 4
#define TY_UINT256 5
#define TY_STRING 6
#define TY_ADDRESS 7
#define TY_BOOL 8
#define TY_POINTER 9

//Get the address of the transaction initiator
address GetSender();
//When calling across contracts, get the address of the original initiator of the transaction
address GetOrigin();
//Get the vnt transfer value that occurs at the same time when the contract is created and called, the unit is wei
uint256 GetValue();
//Get the vnt balance of an address, the unit is wei
uint256 GetBalanceFromAddress(address addr);
//Get the address of the currently executing contract
address GetContractAddress();
//Get block hash
string GetBlockHash(uint64 blocknumber);
//Get block height
uint64 GetBlockNumber();
//Get the timestamp generated by the block
uint64 GetTimestamp();
//Get the address of the block producer
address GetBlockProduser();
// SHA3 encryption operation
string SHA3(string data);
//Get the remaining GAS
uint64 GetGas();
//Get the GasLimit of the current transaction
uint64 GetGasLimit();
//Judgment conditions, if it fails, it returns msg, and the transaction fails. This function is usually used for debugging, please use require in the formal environment
void Assert(bool condition, string msg);
//Transaction rollback
void Revert(string msg);
//Determine whether the condition is established, if it fails, the transaction fails
void Require(bool condition, string msg)
{
     if (condition != true)
     {
          Revert(msg);
     }
}

//The contract transfers money to addr, the transfer amount is amount, the unit is wei, and the transfer fails will be reverted, and it will consume 2300 gas
void SendFromContract(address addr, uint256 amount);
//The contract transfers money to addr, the transfer amount is amount, the unit is wei, the transfer fails to return false, and it consumes 2300 gas
bool TransferFromContract(address addr, uint256 amount);

//Convert the value of int64 into a string
string FromI64(int64 value);
//Convert the value of uint64 into a string
string FromU64(uint64 value);
//Convert the string to int64
int64 ToI64(string value);
//Convert the string to uint64
uint64 ToU64(string value);
//Connect two strings
string Concat(string str1, string str2);
//Determine whether two strings are equal
bool Equal(char *str1, char *str2);

//The following is the debugging function, which is used to print some variables in the contract function, where remark is the prompt file, and the following variables are the printing objects
//Print an address variable
void PrintAddress(string remark, address a);
//Print a string variable
void PrintStr(string remark, string s);
//Print a uint64 number
void PrintUint64T(string remark, uint64 num);
//Print a uint32 number
void PrintUint32T(string remark, uint32 num);
//Print an int64 number
void PrintInt64T(string remark, int64 num);
//Print an int32 number
void PrintInt32T(string remark, int32 num);
void PrintUint256T(string remark, uint256 num);

//Convert the address string into an address
address AddressFrom(string addrStr);
//Convert the address into a string
string AddressToString(address addr);
//Convert the string to uint256 type
uint256 U256From(string u256Str);
//Convert uint256 type to string
string U256ToString(uint256 u256);

//This is a mapping type macro, used to define a mapping variable,
//Where key_type is the key type and val_type is the value type
#define mapping(key_type, val_type) \
     struct \
     {\
          key_type key; \
          val_type value; \
          uint64 mapping1537182776; \
     }

//This is an array type macro, used to define an array variable,
//Where val_type is the array element type
#define array(val_type) \
     struct \
     {\
          uint64 index; \
          val_type value; \
          uint64 length; \
          uint64 array1537182776; \
     }

//The following instructions are related to global variables, and do not need to be explicitly in the contract
//Use these instructions, but will be automatically generated during the second compilation

//Used to register global variables
void AddKeyInfo(uint64 value_address, int32 value_type, uint64 key_address,
                int32 key_type, bool is_array_index);
//Write global variables
void WriteWithPointer(uint64 offset, uint64 baseaddr);
//Read global variables
void ReadWithPointer(uint64 offset, uint64 baseaddr);
//Used to initialize global variables
void InitializeVariables();

// ####math function
// uint64 bit Pow operation
uint64 Pow(uint64 x, uint64 y);

//The following is a mathematical operation function of uint256 type
/// UINT256
// convert uint64 to uint256
uint256 U256FromU64(uint64 x);
// convert int64 to uint256
uint256 U256FromI64(int64 x);
//addition
uint256 U256_Add(uint256 x, uint256 y);
//Subtraction
uint256 U256_Sub(uint256 x, uint256 y);
//multiplication
uint256 U256_Mul(uint256 x, uint256 y);
//division
uint256 U256_Div(uint256 x, uint256 y);
//Take the remainder
uint256 U256_Mod(uint256 x, uint256 y);
// Pow
uint256 U256_Pow(uint256 x, uint256 y);
//Comparison operation
// Cmp compares x and y and returns:
//
// -1 if x <y
// 0 if x == y
// +1 if x> y
//
int32 U256_Cmp(uint256 x, uint256 y);

//Increase the gas value, this instruction does not need to be called explicitly, but will be added to the wasm code by the second compilation
//####gas function
void AddGas(uint64 gas);

/*
CallParams: The first parameter of the cross-contract call
_address: the address to be called
_amount: The token sent to the called address, the unit is wei
_gas: Gas paid for cross-contract calls
*/
typedef struct
{
     address _address;
     uint256 _amount;
     uint64 _gas;
} CallParams;

//Implicitly call WriteWithPointer, ReadWithPointer, AddGas three instructions
//Enable it to be compiled into wasm code
__attribute__((visibility("default"))) void declaredFunction()
{
     WriteWithPointer(0, 0);
     ReadWithPointer(0, 0);
     AddGas(0);
}

//########SafeMath For Uint256###########
uint256 U256SafeMul(uint256 x, uint256 y)
{
     uint256 z = U256_Mul(x, y);
     Require(U256_Cmp(x, U256(0)) == 0 || U256_Cmp(U256_Div(z, x), y) == 0,
             "u256SafeMul overflow");
     return z;
}
uint256 U256SafeDiv(uint256 x, uint256 y)
{
     Require(U256_Cmp(y, U256(0)) == 1, "U256SafeDiv y == 0");
     uint256 z = U256_Div(x, y);
     //This situation will not occur
     Require(U256_Cmp(x, U256_Add(U256_Mul(y, z), U256_Mod(x, y))) == 0,
             "U256SafeDiv overflow");
     return z;
}
uint256 U256SafeSub(uint256 x, uint256 y)
{
     Require(U256_Cmp(x, y) != -1, "U256SafeSub x <y");
     return U256_Sub(x, y);
}
uint256 U256SafeAdd(uint256 x, uint256 y)
{
     uint256 z = U256_Add(x, y);
     Require(U256_Cmp(z, x) != -1 && U256_Cmp(z, y) != -1, "U256SafeAdd overflow");
     return z;
}
//###########################
#endif
//############################################ ##################
// The above is the standard libra
